<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>WebGL Compute Example</title>
	</head>
	<body>
		<!--
		<canvas id="surface" width="128" height="128" style="border: 1px solid black; background-color: red;"></canvas>
		-->
	</body>
<script id="vshader" type="text/plain">
	attribute vec2 vtxpos;
	varying vec2 texpos;
	void main() {
		texpos = (vtxpos / 2.) + vec2(0.5, 0.5);
		gl_Position = vec4(vtxpos, 0, 1);
	}
</script>
<script id="fshader" type="text/plain">
	precision mediump float;
	varying vec2 texpos;
	uniform sampler2D tex0;

	const float A = 97.0 / 255.0;
	const float B = 98.0 / 255.0;
	const float C = 99.0 / 255.0;
	const float SPACE = 95.0 / 255.0;
	const float _0 = 48.0 / 255.0;
	const float _1 = 49.0 / 255.0;
	const float _2 = 50.0 / 255.0;
	const float _3 = 51.0 / 255.0;
	const float _4 = 52.0 / 255.0;
	const float _5 = 53.0 / 255.0;
	const float _6 = 54.0 / 255.0;
	const float _7 = 55.0 / 255.0;
	const float _8 = 56.0 / 255.0;
	const float _9 = 57.0 / 255.0;

	float width() { return PIXELS_WIDE; }
	float height() { return PIXELS_TALL; }

	int get_input_byte(int index) {
		// Scale the index to work with chunks of 4
		float findex = float(index) / 4.0;
		float foffset = mod(findex, 4.0);

		// Convert the 1D index to a 2D index (x and y)
		float x = floor(mod(findex, height()));
		float y = floor(findex / height());

		// Get the vector at x and y
		vec4 data = texture2D(tex0, vec2(x, y));

		// Return the vector element based on the offset
		if (foffset == 0.0)
			return int(floor(data.r * 255.0));
		else if (foffset == 1.0)
			return int(floor(data.g * 255.0));
		else if (foffset == 2.0)
			return int(floor(data.b * 255.0));
		else //if (foffset == 3.0)
			return int(floor(data.a * 255.0));
	}

	int get_output_index() {
		float x = floor(texpos.x * width());
		float y = floor(texpos.y * height());
		float i = (y * height()) + x;
		return int(floor(i));
	}

	void set_dword(float a, float b, float c, float d) {
		gl_FragColor = vec4(a, b, c, d);
	}

	int shift_right(int data, int times) {
	    if (times > 0) {
	        return int(float(data) / exp(vec2(2.0, float(times))));
	    } else {
	        return data;
		}
	}

	int shift_left(int data, const int times) {
	    if (times > 0)
	        return int(float(data) * exp(vec2(2.0, float(times))));
	    else
	        return data;
	}

	vec4 int_to_vec4(const int data) {
		int mask = shift_left(shift_right(data, 8), 8);
		float a = float(data - mask) / 255.0;

		mask = shift_left(shift_right(data, 16), 16);
		float g = float(shift_right(data - mask, 8)) / 255.0;

		mask = shift_left(shift_right(data, 24), 24);
		float b = float(shift_right(data - mask, 16)) / 255.0;

		float r = float(shift_right(data, 24)) / 255.0;
		return vec4(r, g, b, a);
	}

	void main() {
		int i = get_output_index();
		if (i == 0) {
			//vec4 ass = int_to_vec4(0x33FFFFFF);
			//set_dword(ass.r, ass.g, ass.b, ass.a);
			int byte = get_input_byte(0);
			set_dword(A, A, A, SPACE);
		} else if (i == 1) {
			int byte = get_input_byte(1);
			set_dword(B, B, B, SPACE);
		} else {
			int byte = get_input_byte(2);
			set_dword(C, C, C, SPACE);
		}
	}
</script>
<script>
/*
	. How do we have a different sized input and output buffer?
	. How do we write more than one chunk as output at a time?
*/
	var surface = document.createElement('canvas');
	surface.width = 128;
	surface.height = 128;

	// Get A WebGL context
	//var surface = document.getElementById('surface');
	var gl = surface.getContext('webgl') || surface.getContext('experimental-webgl');
	console.info(gl);
//	if (! gl) {
//		return;
//	}

	// Print the open gl version
	console.info(gl.getParameter(gl.VERSION));
	console.info(gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
	console.info(gl.getParameter(gl.VENDOR));
	var ext = gl.getExtension('WEBGL_debug_renderer_info');
	if (ext) {
		console.info(gl.getParameter(ext.UNMASKED_VENDOR_WEBGL));
		console.info(gl.getParameter(ext.UNMASKED_RENDERER_WEBGL));
	}

	// Compile the Vertex Shader
	var shaderSource = document.getElementById('vshader').textContent;
	var shaderVertex = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(shaderVertex, shaderSource);
	gl.compileShader(shaderVertex);
	var compiled = gl.getShaderParameter(shaderVertex, gl.COMPILE_STATUS);
	console.info(compiled);
	if (! compiled) {
		var lastError = gl.getShaderInfoLog(shaderVertex);
		console.error("Shader compile error:" + lastError);
		gl.deleteShader(shaderVertex);
	}

	// Compile the Fragment Shader
	var shaderSource = document.getElementById('fshader').textContent;
	shaderSource = shaderSource.replace('PIXELS_WIDE', surface.width + '.0');
	shaderSource = shaderSource.replace('PIXELS_TALL', surface.height + '.0');
	var shaderFragment = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(shaderFragment, shaderSource);
	gl.compileShader(shaderFragment);
	var compiled = gl.getShaderParameter(shaderFragment, gl.COMPILE_STATUS);
	console.info(compiled);
	if (! compiled) {
		var lastError = gl.getShaderInfoLog(shaderFragment);
		console.error("Shader compile error:" + lastError);
		gl.deleteShader(shaderFragment);
	}

	// Build the program
	var program = gl.createProgram();
	gl.attachShader(program, shaderVertex);
	gl.attachShader(program, shaderFragment);
	gl.linkProgram(program);
	var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
	console.info(linked);
	if (! linked) {
		var lastError = gl.getProgramInfoLog(program);
		console.error("Program link error:" + lastError);
	}
	gl.useProgram(program);

	// Create a vertex buffer
	var vertexPosBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
	var vertices = [-1, -1, 1, -1, -1, 1, 1, 1];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
	vertexPosBuffer.itemSize = 2;
	vertexPosBuffer.numItems = 4;

	// Setup the attributes, uniforms, and textures
	gl.enableVertexAttribArray(program.vertexPosArray);
	gl.vertexAttribPointer(program.vtxpos, 2, gl.FLOAT, false, 0, 0);
	program.vtxpos  = gl.getAttribLocation(program, 'vtxpos');
	program.sampler = [gl.getUniformLocation(program, 'tex0')];
	program.tex     = [gl.createTexture()];

	// Create the input buffer
	var inBuffer = new Uint8Array(4 * surface.width * surface.height);
	for (var i = 0; i < inBuffer.length; ++i) {
		if (i == 0) {
			inBuffer[i] = 255;
		} else {
			inBuffer[i] = 0;
		}
	}

	// Create the output buffer
	var outBuffer = new Uint8Array(4 * surface.width * surface.height);
	console.info('Out buffer size: ' + (4 * surface.width * surface.height));

	function getLine(source, index, size) {
		var line = new Array(size);
		for (var i=0; i<size; ++i) {
			line[i] = String.fromCharCode(source[index + i]);
		}
		return line.join('');
	}

	function blit() {
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, program.tex[0]);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, surface.width, surface.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, inBuffer);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.uniform1i(program.sampler[0], 0);
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
		gl.readPixels(0, 0, surface.width, surface.height, gl.RGBA, gl.UNSIGNED_BYTE, outBuffer);

		var LINE_SIZE = 32;
		var BUFFER_SIZE = 512;// outBuffer.length
		console.info(outBuffer[0]);
		console.info(outBuffer[1]);
		console.info(outBuffer[2]);
		console.info(outBuffer[3]);
		for (var i=0; i<BUFFER_SIZE; i+=LINE_SIZE) {
			console.info(getLine(outBuffer, i, LINE_SIZE));
		}
	};
	blit();
</script>
</html>

<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>WebGL Untar Example</title>
	</head>
	<body>
		<input id="fileInput" type="file" required="required" />
	</body>
<script id="vshader" type="text/plain">
	attribute vec2 vtxpos;
	varying vec2 texpos;
	void main() {
		texpos = (vtxpos / 2.) + vec2(0.5, 0.5);
		gl_Position = vec4(vtxpos, 0, 1);
	}
</script>
<script id="fshader" type="text/plain">
	precision mediump float;
	varying vec2 texpos;
	uniform sampler2D tex0;

	const float A = 97.0 / 255.0;
	const float B = 98.0 / 255.0;
	const float C = 99.0 / 255.0;
	const float SPACE = 95.0 / 255.0;
	const float _0 = 48.0 / 255.0;
	const float _1 = 49.0 / 255.0;
	const float _2 = 50.0 / 255.0;
	const float _3 = 51.0 / 255.0;
	const float _4 = 52.0 / 255.0;
	const float _5 = 53.0 / 255.0;
	const float _6 = 54.0 / 255.0;
	const float _7 = 55.0 / 255.0;
	const float _8 = 56.0 / 255.0;
	const float _9 = 57.0 / 255.0;

	float in_data_length() { return IN_DATA_LENGTH; }
	float in_data_width() { return IN_DATA_SIZE; }
	float in_data_height() { return IN_DATA_SIZE; }
	float out_data_width() { return OUT_DATA_WIDTH; }
	float out_data_height() { return OUT_DATA_HEIGHT; }
/*
	int shift_right(int data, int times) {
		if (times > 0) {
			return int(float(data) / exp(vec2(2.0, float(times))));
		} else {
			return data;
		}
	}

	int shift_left(int data, const int times) {
		if (times > 0)
			return int(float(data) * exp(vec2(2.0, float(times))));
		else
			return data;
	}

	vec4 int_to_vec4(const int data) {
		int mask = shift_left(shift_right(data, 8), 8);
		float a = float(data - mask) / 255.0;

		mask = shift_left(shift_right(data, 16), 16);
		float g = float(shift_right(data - mask, 8)) / 255.0;

		mask = shift_left(shift_right(data, 24), 24);
		float b = float(shift_right(data - mask, 16)) / 255.0;

		float r = float(shift_right(data, 24)) / 255.0;
		return vec4(r, g, b, a);
	}
*/
	int get_output_index() {
		float x = floor(texpos.x * out_data_width());
		float y = floor(texpos.y * out_data_width());
		float i = (y * in_data_height()) + x;
		return int(i);
	}

	vec4 get_input_bytes(int index) {
		// Convert the 1D index to a 2D index (x and y)
		float findex = float(index);
		float x = floor(mod(findex, in_data_height()));
		float y = floor(findex / in_data_height());

		// Get the pixel at x and y
		vec2 cords = vec2(x / in_data_width(), y / in_data_height());
		vec4 data = texture2D(tex0, cords);
		return data;
	}

	void set_output_bytes(vec4 bytes) {
		gl_FragColor = bytes;
	}

	void main() {
		//texture2D(tex0, vec2(texpos.x, texpos.y));
		//texture2D(tex0, vec2(0.0 / in_data_width(), 0.0 / in_data_height()));
		const int TAR_TYPE_FILE = 0;
		const int TAR_TYPE_DIR = 5;

		const int TAR_HEADER_SIZE = 512;
		const int TAR_TYPE_OFFSET = 156;
		const int TAR_TYPE_SIZE = (TAR_TYPE_OFFSET+1);
		const int TAR_SIZE_OFFSET = 124;
		const int TAR_SIZE_SIZE = (TAR_SIZE_OFFSET+12);
		const int TAR_NAME_OFFSET = 0;
		const int TAR_NAME_SIZE = (TAR_NAME_OFFSET+100);
		int i = get_output_index();

		if (i >= TAR_NAME_OFFSET/4 && i < TAR_NAME_SIZE/4) {
			vec4 bytes = get_input_bytes(i);
			//bytes = vec4(0, 0, 0, 0);
			set_output_bytes(bytes);
		} else if (i >= TAR_SIZE_OFFSET/4 && i < TAR_SIZE_SIZE/4) {
			vec4 bytes = get_input_bytes(i);
			//bytes = vec4(0, 0, 0, 0);
			set_output_bytes(bytes);
		} else if (i >= TAR_TYPE_OFFSET/4 && i <= TAR_TYPE_SIZE/4) {
			vec4 bytes = get_input_bytes(i);
			bytes = vec4(bytes.r, 0, 0, 0);
			//bytes = vec4(0, 0, 0, 0);
			set_output_bytes(bytes);
/*
		} else if (i >= 0 && i <= int(in_data_length()) * 4) {
			vec4 file_name[25];
			vec4 bytes = get_input_bytes(i);
			set_output_bytes(bytes);
*/
		} else {
			//vec4 bytes = get_input_bytes(i);
			//set_bytes(bytes);
			gl_FragColor = vec4(0, 0, 0, 0);
		}
	}
</script>
<script type="text/javascript">
/*
	. How do we write more than one chunk as output at a time?
*/
	function main(array_buffer) {
		var OUT_DATA_WIDTH = 128;
		var OUT_DATA_HEIGHT = 128;
		var IN_DATA_SIZE = Math.pow(2, 7);//128 * 128 texture;
		var IN_DATA_LENGTH = array_buffer.byteLength;

		// Get A WebGL context
		var surface = document.createElement('canvas');
		surface.width = OUT_DATA_WIDTH;
		surface.height = OUT_DATA_HEIGHT;
		surface.setAttribute('style', "border: 1px solid black");
		document.body.appendChild(surface);
		var gl = surface.getContext('webgl') || surface.getContext('experimental-webgl');
		if (! gl) {
			console.error('Failed to init WebGL');
			return;
		}

		// Print the open gl version
		console.info('WebGL Version: ' + gl.getParameter(gl.VERSION));
		console.info('GLSL Version: ' + gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
		console.info('Vendor: ' + gl.getParameter(gl.VENDOR));
		/*
		var ext = gl.getExtension('WEBGL_debug_renderer_info');
		if (ext) {
			console.info(gl.getParameter(ext.UNMASKED_VENDOR_WEBGL));
			console.info(gl.getParameter(ext.UNMASKED_RENDERER_WEBGL));
		}
		*/

		// Compile the Vertex Shader
		var shaderSource = document.getElementById('vshader').textContent;
		var shaderVertex = gl.createShader(gl.VERTEX_SHADER);
		gl.shaderSource(shaderVertex, shaderSource);
		gl.compileShader(shaderVertex);
		var compiled = gl.getShaderParameter(shaderVertex, gl.COMPILE_STATUS);
		if (! compiled) {
			var lastError = gl.getShaderInfoLog(shaderVertex);
			console.error("Shader compile error:" + lastError);
			gl.deleteShader(shaderVertex);
		}

		// Inject our sizes into the shader source code
		var shaderSource = document.getElementById('fshader').textContent;
		shaderSource = shaderSource.replace(/OUT_DATA_WIDTH/g, OUT_DATA_WIDTH + '.0');
		shaderSource = shaderSource.replace(/OUT_DATA_HEIGHT/g, OUT_DATA_HEIGHT + '.0');
		shaderSource = shaderSource.replace(/IN_DATA_SIZE/g, IN_DATA_SIZE + '.0');
		shaderSource = shaderSource.replace(/IN_DATA_LENGTH/g, IN_DATA_LENGTH + '.0');

		// Compile the Fragment Shader
		var shaderFragment = gl.createShader(gl.FRAGMENT_SHADER);
		gl.shaderSource(shaderFragment, shaderSource);
		gl.compileShader(shaderFragment);
		var compiled = gl.getShaderParameter(shaderFragment, gl.COMPILE_STATUS);
		if (! compiled) {
			var lastError = gl.getShaderInfoLog(shaderFragment);
			console.error("Shader compile error:" + lastError);
			gl.deleteShader(shaderFragment);
		}

		// Build the program
		var program = gl.createProgram();
		gl.attachShader(program, shaderVertex);
		gl.attachShader(program, shaderFragment);
		gl.linkProgram(program);
		var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
		if (! linked) {
			var lastError = gl.getProgramInfoLog(program);
			console.error("Program link error:" + lastError);
		}
		gl.useProgram(program);

		// Create a vertex buffer
		var vertexPosBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
		var vertices = [-1, -1, 1, -1, -1, 1, 1, 1];
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		vertexPosBuffer.itemSize = 2;
		vertexPosBuffer.numItems = 4;

		// Setup the attributes, uniforms, and textures
		gl.enableVertexAttribArray(program.vertexPosArray);
		gl.vertexAttribPointer(program.vtxpos, 2, gl.FLOAT, false, 0, 0);
		program.vtxpos = gl.getAttribLocation(program, 'vtxpos');
		program.sampler = [gl.getUniformLocation(program, 'tex0')];
		program.tex = [gl.createTexture()];

		// Create the input buffer
		var inBuffer = new Uint8Array(4 * IN_DATA_SIZE * IN_DATA_SIZE);
		console.info('In buffer size:  ' + inBuffer.byteLength);
		console.info('Data size:       ' + array_buffer.byteLength);
		var view = new Uint8Array(array_buffer);
		for (var i = 0; i < view.length; ++i) {
			inBuffer[i] = view[i];
		}

		// Create the output buffer
		var outBuffer = new Uint8Array(4 * OUT_DATA_WIDTH * OUT_DATA_HEIGHT);
		console.info('Out buffer size: ' + outBuffer.byteLength);

		function getLine(source, index, size) {
			var line = new Array(size);
			for (var i=0; i<size; ++i) {
				line[i] = String.fromCharCode(source[index + i]);
			}
			return line.join('');
		}

		function blit() {
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, program.tex[0]);
			gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, IN_DATA_SIZE, IN_DATA_SIZE, 0, gl.RGBA, gl.UNSIGNED_BYTE, inBuffer);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.uniform1i(program.sampler[0], 0);
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			gl.readPixels(0, 0, OUT_DATA_WIDTH, OUT_DATA_HEIGHT, gl.RGBA, gl.UNSIGNED_BYTE, outBuffer);

			var LINE_SIZE = 100;
			var BUFFER_SIZE = IN_DATA_LENGTH;// outBuffer.length
			for (var i=0; i<outBuffer.length; i+=LINE_SIZE) {
				console.info(getLine(outBuffer, i, LINE_SIZE));
			}
		};
		blit();

		console.info(getLine(outBuffer, 0, 100));
		console.info(parseInt(getLine(outBuffer, 124, 136), 8));
		console.info(getLine(outBuffer, 156, 157));
	}

	var fileInput = document.getElementById('fileInput');
	fileInput.onchange = function() {
		// Just return if there is no file selected
		if (fileInput.files.length === 0) {
			entryList.innerHTML = 'No file selected';
			return;
		}

		// Get the selected file
		var file = fileInput.files[0];
		var reader = new FileReader();
		reader.onload = function (evt) {
			var array_buffer = reader.result;
			main(array_buffer);
		};
		reader.readAsArrayBuffer(file);
	};
</script>
</html>

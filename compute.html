<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>WebGL Compute Example</title>
	</head>
	<body>
		<canvas id="surface" width="128" height="128" style="border: 1px solid black; background-color: red;"></canvas>
	</body>
<script id="vshader" type="text/plain">
	attribute vec2 vtxpos;
	varying vec2 texpos;
	void main() {
		texpos = (vtxpos / 2.) + vec2(0.5, 0.5);
		gl_Position = vec4(vtxpos, 0, 1);
	}
</script>
<script id="fshader" type="text/plain">
	precision mediump float;
	varying vec2 texpos;
	uniform sampler2D tex0;
	void main() {
		const float A = 97.0 / 255.0;
		const float S = 115.0 / 255.0;
		const float SPACE = 95.0 / 255.0;
		const float H = 104.0 / 255.0;
		const float O = 111.0 / 255.0;
		const float L = 108.0 / 255.0;
		const float E = 101.0 / 255.0;

		//gl_FragColor = vec4(0, 0, 0, 1);
		//float x = floor(texpos.x * PIXELS_WIDE);
		//float y = floor(texpos.y * PIXELS_TALL);
		vec4 color = texture2D(tex0, texpos);
		if (color.r == 1.0 /*mod(x, 2.0) == 1.0*/) {
			gl_FragColor = vec4(A, S, S, SPACE);
		} else {
			gl_FragColor = vec4(H, O, L, E);
		}
		//gl_FragColor = color;
	}
</script>
<script>
/*
	. How do we have a different sized input and output buffer?
	. How do we write more than one chunk as output at a time?
*/
	// Get A WebGL context
	var surface = document.getElementById('surface');
	var gl = surface.getContext('webgl') || surface.getContext('experimental-webgl');
	console.info(gl);
//	if (! gl) {
//		return;
//	}

	// Print the open gl version
	console.info(gl.getParameter(gl.VERSION));
	console.info(gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
	console.info(gl.getParameter(gl.VENDOR));
	var ext = gl.getExtension('WEBGL_debug_renderer_info');
	if (ext) {
		console.info(gl.getParameter(ext.UNMASKED_VENDOR_WEBGL));
		console.info(gl.getParameter(ext.UNMASKED_RENDERER_WEBGL));
	}

	// Compile the Vertex Shader
	var shaderSource = document.getElementById('vshader').textContent;
	var shaderVertex = gl.createShader(gl.VERTEX_SHADER);
	gl.shaderSource(shaderVertex, shaderSource);
	gl.compileShader(shaderVertex);
	var compiled = gl.getShaderParameter(shaderVertex, gl.COMPILE_STATUS);
	console.info(compiled);
	if (! compiled) {
		var lastError = gl.getShaderInfoLog(shaderVertex);
		console.error("Shader compile error:" + lastError);
		gl.deleteShader(shaderVertex);
	}

	// Compile the Fragment Shader
	var shaderSource = document.getElementById('fshader').textContent;
	shaderSource = shaderSource.split('PIXELS_WIDE').join(surface.width + '.').split('PIXELS_TALL').join(surface.height + '.');
	var shaderFragment = gl.createShader(gl.FRAGMENT_SHADER);
	gl.shaderSource(shaderFragment, shaderSource);
	gl.compileShader(shaderFragment);
	var compiled = gl.getShaderParameter(shaderFragment, gl.COMPILE_STATUS);
	console.info(compiled);
	if (! compiled) {
		var lastError = gl.getShaderInfoLog(shaderFragment);
		console.error("Shader compile error:" + lastError);
		gl.deleteShader(shaderFragment);
	}

	// Build the program
	var program = gl.createProgram();
	gl.attachShader(program, shaderVertex);
	gl.attachShader(program, shaderFragment);
	gl.linkProgram(program);
	var linked = gl.getProgramParameter(program, gl.LINK_STATUS);
	console.info(linked);
	if (! linked) {
		var lastError = gl.getProgramInfoLog(program);
		console.error("Program link error:" + lastError);
	}
	gl.useProgram(program);

	// Create a vertex buffer
	var vertexPosBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, vertexPosBuffer);
	var vertices = [-1, -1, 1, -1, -1, 1, 1, 1];
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
	vertexPosBuffer.itemSize = 2;
	vertexPosBuffer.numItems = 4;

	// Setup the attributes, uniforms, and textures
	gl.enableVertexAttribArray(program.vertexPosArray);
	gl.vertexAttribPointer(program.vtxpos, 2, gl.FLOAT, false, 0, 0);
	program.vtxpos  = gl.getAttribLocation(program, 'vtxpos');
	program.sampler = [gl.getUniformLocation(program, 'tex0')];
	program.tex     = [gl.createTexture()];

	// Create the input buffer
	var inBuffer = new Uint8Array(4 * surface.width * surface.height);
	for (var i = 0; i < inBuffer.length; ++i) {
		if (i == 0) {
			inBuffer[i] = 255;
		} else {
			inBuffer[i] = 0;
		}
	}

	// Create the output buffer
	var outBuffer = new Uint8Array(4 * surface.width * surface.height);
	console.info('Out buffer size: ' + (4 * surface.width * surface.height));

	function getLine(source, index, size) {
		var line = new Array(size);
		for (var i=0; i<size; ++i) {
			line[i] = String.fromCharCode(source[index + i]);
		}
		return line.join('');
	}

	function blit() {
		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, program.tex[0]);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, surface.width, surface.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, inBuffer);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.uniform1i(program.sampler[0], 0);
		gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
		gl.readPixels(0, 0, surface.width, surface.height, gl.RGBA, gl.UNSIGNED_BYTE, outBuffer);

		var LINE_SIZE = 32;
		for (var i=0; i<outBuffer.length; i+=LINE_SIZE) {
			console.info(getLine(outBuffer, i, LINE_SIZE));
		}
	};
	blit();
</script>
</html>
